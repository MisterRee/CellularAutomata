<!doctype html>
<html>
	<head>
		<style>
			body{
				margin: 0;
			}

			canvas{
				position: absolute;
				width: 100%;
				height: 100%;
			}
		</style>
	</head>
	<body>
		<canvas></canvas>
		<script>
			/*
				HEAT MAP CELL AUTOMATA, WITH MOUSE OVER EVENT COLORING
				A: Danny lee
				D: 2/6/2017

				This page fills the screen with grids which follows the celluar automata rules of the 'game of life.'
				However, instead of cells having a binary 'alive or dead' state, living cells merely darken its cell gradually, instead of instantly.
				The same goes for the opposite; 'dead' cells gradually lighten the cell color over time.

				The cells are only grayscale from black to white by the automata. Mousing over cells colors them to a randomly generated color.
				The colors left behind your mouse will decay into white, and may create new colors along the decay cycyle.

				Clicking rerolls your color. Mixing colors together can create some unpredictable effects with how the colors combine together.

				The page will output steady, sine-wave beeps at each iteration of the cell automation. The amount of cells that turn alive account for the direct frequency of the signal.

				Mousing over and influncing the page will change the signal as well, in different ways depending on the colors splashed to the cells.
					Red cells will detune the signal;
					Green cells will change the lowpass frequency that is being applied to the signal;
					Blue cells will increase the frequency
			*/

			'use strict';
			const canvas = document.querySelector( 'canvas' );
			const ctx = canvas.getContext( '2d' );
			const atx = new AudioContext();

			// Behavioral variables, feel free to change
			const refreshRate = 75; // How quickly the page refreshes in milliseconds
			const width = 25; // How many grids there are in the x-axis
			const height = 25; // How many grids there are in the y-axis
			const darkenRate = 16.4; // How quickyly 'live' cells darken grids that are alive
			const lightenRate = 12.8; // How quickly 'dead' cells lighten grids that are dead

			// Audio variables
			const freqRatio = 1.08; // Base of an exponential, powered to the amount of cells that turn alive during the iteration
			const bFreq = 30;
			const bAttack = 0.02;
			const bDecay = 0.05;
			const bSustain = refreshRate / 1000;

			// Mouse interactivity variables
			const maxColorValueCoefficient = 638; // This fancy variable is the commulative total of rgb values; right now requires to be greater than 255
			const colorRollThreshold = 0.2; // Should be number between 0 - 0.5, forces rerolls of colors more frequently the higher this is
			const colorDarknessThreshold = 0.1; // Number between 0 - 1, causes very dark colors to brighten to a colored state even when a cell is alive
			const variedCoeffient = 128;
			const colorCoeffient = 10; // A number that divides the amount of colorVarience that effects the audio behaviors
			let mouseEffectSize = 5; // Should be odd number. Acts like a palette size
			let mouseColor = { r : 0,
												 g : 0,
											   b : 0 };
			let colorVarience = { r : 0,
												 		g : 0,
											   		b : 0 };

			let isAudioPlaying = false;
			let numCellFlips = 0;

			// Holds the dimension in pixels for each grid
			let grid_width = 0;
			let grid_height = 0;

			// Holds the grid object in which the program manipulates repeatedly
			let grid = []; // Production var
			let temp = []; // Editing var
			let currentMouseGrid = { x : -1, y : -1 }; // Coordinates of the mouse position within the grid

			// function to be called whenever the browser is resized,
			const resize = function(){
				grid_width = canvas.clientWidth / width;
				grid_height = canvas.clientHeight / height;
				canvas.width = width * grid_width;
				canvas.height = height * grid_height;
			};

			// function that needs to only be called once, rolls a random color for the person to use
			const generateMouseColor = function(){
				// Red generation always gets favored as gets free dice roll from 0 - 255 in any case
				mouseColor.r = Math.floor( Math.random() * 256 );

				// Green generation can potentially be limited in its maximum value by the roll of red
				if( 255 < maxColorValueCoefficient - mouseColor.r ){
					mouseColor.g = Math.floor( Math.random() * 256 );
				} else {
					mouseColor.g = Math.floor( Math.random() * maxColorValueCoefficient - mouseColor.r + 1 );
				}

				// Blue generation can potentially be limited in its maximum value by the roll of red and green
				if( 255 < maxColorValueCoefficient - ( mouseColor.r + mouseColor.g )){
					mouseColor.b = Math.floor( Math.random() * 256 );
				} else {
					mouseColor.b = Math.floor( Math.random() * maxColorValueCoefficient - ( mouseColor.r + mouseColor.g ));
				}

				// Reroll the values if the left over mcvc is too high, leading to a base color that is too bright
				if( maxColorValueCoefficient * ( 1 - colorRollThreshold ) < maxColorValueCoefficient - ( mouseColor.r + mouseColor.g + mouseColor.b )){
					generateMouseColor();
				}
				// Reroll the values if the left over mcvc is too low, leading to a base color that is too dark
				else if( maxColorValueCoefficient * colorRollThreshold > maxColorValueCoefficient - ( mouseColor.r + mouseColor.g + mouseColor.b )){
					generateMouseColor();
				}
			};

			// Adds event listeners to the canvas, only needs to be called once
			const mouseActivity = function( event ){
				canvas.addEventListener('mousemove', function( event ){
					currentMouseGrid.x = Math.floor( event.clientX / canvas.clientWidth * width );
					currentMouseGrid.y = Math.floor( event.clientY / canvas.clientHeight * height );
				});

				canvas.addEventListener('mouseout', function( event ){
					currentMouseGrid.x = -1;
					currentMouseGrid.y = -1;
				});

				canvas.addEventListener('click', function( event ){
					generateMouseColor();
				});
			};

			// function to be run before the looping functions begin
			const init = function(){
				// Ensures that the mouseEffectSize is indeed an odd number
				if( mouseEffectSize % 2 === 1 ){
					mouseEffectSize++;
				}

				resize();
				generateMouseColor();
				mouseActivity();

				// Initially populating cells
				for( let y = 0; y < height; y++ ){
					grid[ y ] = [];

					for( let x = 0; x < width; x++ ){
						grid[ y ][ x ] = { cs : Math.round( Math.random() ),
															 rcv : 255,
														   gcv : 255,
															 bcv : 255};
					}
				}

				temp = grid;
			};

			// Neighbor scanning function that is continuously called
			const runAutomata = function(){
				// Swapping references is cheaper than copying over variables
				let swap = grid;
				grid = temp;
				temp = swap;
				numCellFlips = 0;

				for( let y = 0; y < height; y++ ){
					for( let x = 0; x < width; x++){
						let cnc = 0;

						for( let i = 0; i < 9; i++ ){
							/*
								Checking neighbors through a loop through the neighbors.
								Index 4 is the coordinates of the cell in question of the check
								[ 0 ][ 1 ][ 2 ]
								[ 3 ][ x ][ 5 ]
								[ 6 ][ 7 ][ 8 ]
							*/

							// Skipping out of bound scans
							if( y - 1 < 0 && i < 3 ){
								continue;
							} else if( y + 1 >= height && i > 5 ){
								continue;
							} else if( x - 1 < 0 && i % 3 === 0 ){
								continue;
							} else if( x + 1 >= width && ( i - 2 ) % 3 === 0 ){
								continue;
							}

							switch(i){
								// Neighbors above
								case 0:
								case 1:
								case 2:
									if( grid[ y - 1 ][ x + i - 1 ].cs === 1 ){
										cnc++;
									}
									break;
								// Neighbor to the left
								case 3:
									if( grid[ y ][ x - 1 ].cs === 1 ){
									 cnc++;
									}
									break;
								case 4:
									break;
								// Neighbor to the right
								case 5:
									if( grid[ y ][ x + 1 ].cs === 1 ){
									 cnc++;
									}
									break;
								// Neighbors below
								case 6:
								case 7:
								case 8:
									if( grid[ y + 1 ][ x + i - 7 ].cs === 1 ){
										cnc++;
									}
									break;
								default:
									break;
							}
						}

						// first rule
						if( cnc < 2 && grid[ y ][ x ].cs === 1 ){
							temp[ y ][ x ].cs = 0;
						}

						// second rule
						if( cnc < 1 && cnc > 4 && grid[ y ][ x ].cs === 1 ){
							temp[ y ][ x ].cs = 0;
						}

						// third rule
						if( cnc > 3 && grid[ y ][ x ].cs === 1 ){
							temp[ y ][ x ].cs = 0;
						}

						// fourth rule
						if( cnc == 3 && grid[ y ][ x ].cs === 0){
							temp[ y ][ x ].cs = 1;
							numCellFlips++;
						}
					}
				}

				grid = temp;
			};

			// Helper function to limit color values between 0 - 255
			const colorLimiter = function( obj, ddr, dlr ){
				if( obj.cs === 1 ){
					if( obj.rcv - ddr < 0 ){
						obj.rcv = 0;
					} else {
						obj.rcv -= ddr;
					}

					if( obj.gcv - ddr < 0 ){
						obj.gcv = 0;
					} else {
						obj.gcv -= ddr;
					}

					if( obj.bcv - ddr < 0 ){
						obj.bcv = 0;
					} else {
						obj.bcv -= ddr;
					}
				} else {
					if( obj.rcv + dlr > 255 ){
						obj.rcv = 255;
					} else {
						obj.rcv += dlr;
					}

					if( obj.gcv + dlr > 255 ){
						obj.gcv = 255;
					} else {
						obj.gcv += dlr;
					}

					if( obj.bcv + dlr > 255 ){
						obj.bcv = 255;
					} else {
						obj.bcv += dlr;
					}
				}

				obj.rcv = Math.floor(obj.rcv);
				obj.gcv = Math.floor(obj.gcv);
				obj.bcv = Math.floor(obj.bcv);
				return obj;
			};

			// Helper function to limit color values between 0 - 255, but with different darkening values and lmits for each color
			// Cells that are called to this color limiter function will 'decay' into the rolled base color.
			const variedColorLimiter = function( obj, rddr, gddr, bddr, dlr ){
				if( obj.cs === 1 ){
					if( Math.abs( obj.rcv - mouseColor.r / colorDarknessThreshold ) < ( 255 * colorDarknessThreshold  / 2) ){
						obj.rcv = mouseColor.r;
					} else if ( obj.rcv < mouseColor.r / colorDarknessThreshold ){
						obj.rcv += dlr;
					} else {
						obj.rcv -= rddr;
					}

					if( Math.abs( obj.gcv - mouseColor.g / colorDarknessThreshold ) < ( 255 * colorDarknessThreshold  / 2) ){
						obj.gcv = mouseColor.g;
					} else if( obj.gcv < mouseColor.g / colorDarknessThreshold ){
						obj.gcv += dlr;
					} else {
						obj.gcv -= gddr;
					}

					if( Math.abs( obj.bcv - mouseColor.b / colorDarknessThreshold ) < ( 255 * colorDarknessThreshold / 2) ){
						obj.bcv = mouseColor.bug;
					} else if( obj.bcv < mouseColor.b / colorDarknessThreshold ){
						obj.bcv += dlr;
					} else {
						obj.bcv -= bddr;
					}
				} else {
					if( obj.rcv + dlr > mouseColor.r ){
						obj.rcv = mouseColor.r;
					} else {
						obj.rcv += dlr;
					}

					if( obj.gcv + dlr > mouseColor.g ){
						obj.gcv = mouseColor.g;
					} else {
						obj.gcv += dlr;
					}

					if( obj.bcv + dlr > mouseColor.b ){
						obj.bcv = mouseColor.b;
					} else {
						obj.bcv += dlr;
					}
				}

				obj.rcv = Math.floor(obj.rcv);
				obj.gcv = Math.floor(obj.gcv);
				obj.bcv = Math.floor(obj.bcv);
				return obj;
			};

			const calcColor = function( cell ){
				if( cell.rcv > cell.gcv &&
						cell.rcv > cell.bcv ){
					if( cell.gcv > cell.bcv ){
						colorVarience.r += cell.rcv - cell.bcv;
						colorVarience.g += cell.rcv - cell.gcv;
					} else {
						colorVarience.r += cell.rcv - cell.gcv;
						colorVarience.b += cell.rcv - cell.bcv;
					}
				}
	 else if( cell.gcv > cell.rcv &&
						cell.gcv > cell.bcv ){
					if( cell.rcv > cell.bcv ){
						colorVarience.g += cell.gcv - cell.bcv;
						colorVarience.r += cell.gcv - cell.rcv;
					} else {
						colorVarience.g += cell.gcv - cell.rcv;
						colorVarience.b += cell.gcv - cell.bcv;
					}
				}
	 else if( cell.bcv > cell.rcv &&
						cell.bcv > cell.gcv ){
					if( cell.rcv > cell.bcv ){
						colorVarience.b += cell.bcv - cell.bcv;
						colorVarience.r += cell.bcv - cell.rcv;
					} else {
						colorVarience.b += cell.bcv - cell.rcv;
						colorVarience.r += cell.bcv - cell.bcv;
					}
				}
			};

			const runAudio = function(){
				if( !isAudioPlaying ){
					isAudioPlaying = true;

					const carrier = atx.createOscillator();
					const envelope = atx.createGain();
					const filter = atx.createBiquadFilter();

					carrier.connect( envelope );
					envelope.connect( filter );
					filter.connect( atx.destination );

					carrier.frequency.value = bFreq + Math.floor( Math.pow( freqRatio, numCellFlips ) + colorVarience.b );
					carrier.detune.value = colorVarience.r;

					envelope.gain.value = 0;
					envelope.gain.linearRampToValueAtTime( 1, atx.currentTime + bAttack );
					envelope.gain.linearRampToValueAtTime( 0, atx.currentTime + bAttack + bDecay );

					filter.type = "lowpass";
					filter.frequency.value = 30 + colorVarience.g * 2;

					carrier.connect( atx.destination );

					carrier.start();
					carrier.stop( atx.currentTime + bSustain );
					setTimeout( function(){ isAudioPlaying = false; }, bSustain );
				}
			};

			// Visually drawing function, which needs to be continuously called
			const draw = function(){
				// Clear canvas before redraw
				ctx.fillStyle = 'white';
				ctx.fillRect(0, 0, canvas.width, canvas.height );

				colorVarience = { r: 0,
													g: 0,
													b: 0 };
				runAutomata();

				for( let y = 0; y < height; y++ ){
					for( let x = 0; x < width; x++ ){
						var dist = Math.abs( currentMouseGrid.y - y ) + Math.abs( currentMouseGrid.x - x );
						if( currentMouseGrid.y !== -1 && currentMouseGrid !== -1 &&
							Math.abs( currentMouseGrid.y - y ) <= Math.floor( mouseEffectSize / 2 ) &&
								dist < Math.ceil( mouseEffectSize / 2 ) ){
							grid[ y ][ x ] =
								variedColorLimiter( grid[ y ][ x ],
									darkenRate * mouseColor.r / variedCoeffient  / (dist + 1),
									darkenRate * mouseColor.g / variedCoeffient / (dist + 1),
									darkenRate * mouseColor.b / variedCoeffient / (dist + 1),
									lightenRate);
							ctx.fillStyle = "rgb(" + grid[ y ][ x ].rcv + "," +
																			 grid[ y ][ x ].gcv + "," +
																			 grid[ y ][ x ].bcv + ")";
							ctx.fillRect( x * grid_width, y * grid_height, grid_width, grid_height );
						} else {
							// Cycling colors, alive cells become darker and dead cells become lighter
							grid[ y ][ x ] = colorLimiter( grid[ y ][ x ], darkenRate, lightenRate );
							ctx.fillStyle = "rgb(" + grid[ y ][ x ].rcv + "," +
																			 grid[ y ][ x ].gcv + "," +
																			 grid[ y ][ x ].bcv + ")";
							ctx.fillRect( x * grid_width + grid_width / 10, y * grid_height + grid_height / 10, grid_width * 4 / 5, grid_height * 4 / 5 );
						}

						calcColor( grid[ y ][ x ] );
					}
				}

				colorVarience.r = Math.floor( colorVarience.r / ( width * height / colorCoeffient  ) );
				colorVarience.g = Math.floor( colorVarience.g / ( width * height / colorCoeffient ) );
				colorVarience.b = Math.floor( colorVarience.b / ( width * height / colorCoeffient ) );
				runAudio();
			}

			init();
			window.onresize = resize();
			window.setInterval( draw, refreshRate );
		</script>
	</body>
</html>
