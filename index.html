<!doctype html>
<html>
	<head>
		<style>
			body{
				margin: 0;
			}

			canvas{
				position: absolute;
				width: 100%;
				height: 100%;
			}
		</style>
	</head>
	<body>
		<canvas></canvas>
		<script>
			/*
				HEAT MAP CELL AUTOMATA, WITH MOUSE OVER EVENT COLORING
				A: Danny lee
				D: 2/6/2017

				This page fills the screen with grids which follows the celluar automata rules of the 'game of life.'
				However, instead of cells having a binary 'alive or dead' state, living cells merely darken its cell gradually, instead of instantly.
				The same goes for the opposite; 'dead' cells gradually lighten the cell color over time.

				The cells are only grayscale from black to white by the automata. Mousing over cells colors them to a randomly generated color.
				The colors left behind your mouse will decay into white, and may create new colors along the decay cycyle.

				Clicking rerolls your color. Mixing colors together can create some unpredictable effects with how the colors combine together.
			*/

			'use strict';
			const canvas = document.querySelector( 'canvas' );
			const ctx = canvas.getContext( '2d' );

			// Behavioral variables, feel free to change
			const refreshRate = 75; // How quickly the page refreshes in milliseconds
			const width = 25; // How many grids there are in the x-axis
			const height = 25; // How many grids there are in the y-axis
			const darkenRate = 16.4; // How quickyly 'live' cells darken grids that are alive
			const lightenRate = 12.8; // How quickly 'dead' cells lighten grids that are dead

			// Mouse interactivity variables
			let mouseEffectSize = 5; // Should be odd number. Acts like a palette size
			const maxColorValueCoefficient = 638; // This fancy variable is the commulative total of rgb values; right now requires to be greater than 255
			const colorRollThreshold = 0.2; // Should be number between 0 - 0.5, forces rerolls of colors more frequently the higher this is
			const colorDarknessThreshold = 0.1; // Number between 0 - 1, causes very dark colors to brighten to a colored state even when a cell is alive
			let mouseColor = { r : 0,
												 g : 0,
											   b : 0 };

				// function that needs to only be called once, rolls a random color for the person to use
				let generateMouseColor = function(){
					// Red generation always gets favored as gets free dice roll from 0 - 255 in any case
					mouseColor.r = Math.floor( Math.random() * 256 );

					// Green generation can potentially be limited in its maximum value by the roll of red
					if( 255 < maxColorValueCoefficient - mouseColor.r ){
						mouseColor.g = Math.floor( Math.random() * 256 );
					} else {
						mouseColor.g = Math.floor( Math.random() * maxColorValueCoefficient - mouseColor.r + 1 );
					}

					// Blue generation can potentially be limited in its maximum value by the roll of red and green
					if( 255 < maxColorValueCoefficient - ( mouseColor.r + mouseColor.g )){
						mouseColor.b = Math.floor( Math.random() * 256 );
					} else {
						mouseColor.b = Math.floor( Math.random() * maxColorValueCoefficient - ( mouseColor.r + mouseColor.g ));
					}

					// Reroll the values if the left over mcvc is too high, leading to a base color that is too bright
					if( maxColorValueCoefficient * ( 1 - colorRollThreshold ) < maxColorValueCoefficient - ( mouseColor.r + mouseColor.g + mouseColor.b )){
						generateMouseColor();
					}
					// Reroll the values if the left over mcvc is too low, leading to a base color that is too dark
					else if( maxColorValueCoefficient * colorRollThreshold > maxColorValueCoefficient - ( mouseColor.r + mouseColor.g + mouseColor.b )){
						generateMouseColor();
					}
				}

				// Holds the dimension in pixels for each grid
				let grid_width = 0;
				let grid_height = 0;

				// Holds the grid object in which the program manipulates repeatedly
				let grid = []; // Production var
				let temp = []; // Editing var
				let currentMouseGrid = { x : -1, y : -1 }; // Coordinates of the mouse position within the grid

				// function to be called whenever the browser is resized,
				let resize = function(){
					grid_width = canvas.clientWidth / width;
					grid_height = canvas.clientHeight / height;
					canvas.width = width * grid_width;
					canvas.height = height * grid_height;
				}

				// Adds event listeners to the canvas, only needs to be called once
				let mouseActivity = function( event ){
					canvas.addEventListener('mousemove', function( event ){
						currentMouseGrid.x = Math.floor( event.clientX / canvas.clientWidth * width );
						currentMouseGrid.y = Math.floor( event.clientY / canvas.clientHeight * height );
					});

					canvas.addEventListener('mouseout', function( event ){
						currentMouseGrid.x = -1;
						currentMouseGrid.y = -1;
					});

					canvas.addEventListener('click', function( event ){
						generateMouseColor();
					});
				}

			// function to be run before the looping functions begin
			let init = function(){
				// Ensures that the mouseEffectSize is indeed an odd number
				if( mouseEffectSize % 2 === 1 ){
					mouseEffectSize++;
				}

				resize();
				generateMouseColor();
				mouseActivity();

				// Initially populating cells
				for( let y = 0; y < height; y++ ){
					grid[ y ] = [];

					for( let x = 0; x < width; x++ ){
						grid[ y ][ x ] = { cs : Math.round( Math.random() ),
															 rcv : 255,
														   gcv : 255,
															 bcv : 255};
					}
				}

				temp = grid;
			}

				// Helper function to limit color values between 0 - 255
				let colorLimiter = function( obj, ddr, dlr ){
					if( obj.cs === 1 ){
						if( obj.rcv - ddr < 0 ){
							obj.rcv = 0;
						} else {
							obj.rcv -= ddr;
						}

						if( obj.gcv - ddr < 0 ){
							obj.gcv = 0;
						} else {
							obj.gcv -= ddr;
						}

						if( obj.bcv - ddr < 0 ){
							obj.bcv = 0;
						} else {
							obj.bcv -= ddr;
						}
					} else {
						if( obj.rcv + dlr > 255 ){
							obj.rcv = 255;
						} else {
							obj.rcv += dlr;
						}

						if( obj.gcv + dlr > 255 ){
							obj.gcv = 255;
						} else {
							obj.gcv += dlr;
						}

						if( obj.bcv + dlr > 255 ){
							obj.bcv = 255;
						} else {
							obj.bcv += dlr;
						}
					}

					Math.floor(obj.rcv);
					Math.floor(obj.gcv);
					Math.floor(obj.bcv);
					return obj;
				}

				// Helper function to limit color values between 0 - 255, but with different darkening values and lmits for each color
				// Cells that are called to this color limiter function will 'decay' into the rolled base color.
				let variedColorLimiter = function( obj, rddr, gddr, bddr, dlr ){
					if( obj.cs === 1 ){
						if( Math.abs( obj.rcv - mouseColor.r / colorDarknessThreshold ) < ( 255 * colorDarknessThreshold  / 2) ){
							obj.rcv = mouseColor.r;
						} else if ( obj.rcv < mouseColor.r / colorDarknessThreshold ){
							obj.rcv += dlr;
						} else {
							obj.rcv -= rddr;
						}

						if( Math.abs( obj.gcv - mouseColor.g / colorDarknessThreshold ) < ( 255 * colorDarknessThreshold  / 2) ){
							obj.gcv = mouseColor.g;
						} else if( obj.gcv < mouseColor.g / colorDarknessThreshold ){
							obj.gcv += dlr;
						} else {
							obj.gcv -= gddr;
						}

						if( Math.abs( obj.bcv - mouseColor.b / colorDarknessThreshold ) < ( 255 * colorDarknessThreshold / 2) ){
							obj.bcv = mouseColor.bug;
						} else if( obj.bcv < mouseColor.b / colorDarknessThreshold ){
							obj.bcv += dlr;
						} else {
							obj.bcv -= bddr;
						}
					} else {
						if( obj.rcv + dlr > mouseColor.r ){
							obj.rcv = mouseColor.r;
						} else {
							obj.rcv += dlr;
						}

						if( obj.gcv + dlr > mouseColor.g ){
							obj.gcv = mouseColor.g;
						} else {
							obj.gcv += dlr;
						}

						if( obj.bcv + dlr > mouseColor.b ){
							obj.bcv = mouseColor.b;
						} else {
							obj.bcv += dlr;
						}
					}

					Math.floor(obj.rcv);
					Math.floor(obj.gcv);
					Math.floor(obj.bcv);
					return obj;
				}

				// Neighbor scanning function that is continuously called
				let runAutomata = function(){
					// Swapping references is cheaper than copying over variables
					let swap = grid;
					grid = temp;
					temp = swap;

					for( let y = 0; y < height; y++ ){
						for( let x = 0; x < width; x++){
							let cnc = 0;

							for( let i = 0; i < 9; i++ ){
								/*
									Checking neighbors through a loop through the neighbors.
									Index 4 is the coordinates of the cell in question of the check
									[ 0 ][ 1 ][ 2 ]
									[ 3 ][ x ][ 5 ]
									[ 6 ][ 7 ][ 8 ]
								*/

								// Skipping out of bound scans
								if( y - 1 < 0 && i < 3 ){
									continue;
								} else if( y + 1 >= height && i > 5 ){
									continue;
								} else if( x - 1 < 0 && i % 3 === 0 ){
									continue;
								} else if( x + 1 >= width && ( i - 2 ) % 3 === 0 ){
									continue;
								}

								switch(i){
									// Neighbors above
									case 0:
									case 1:
									case 2:
										if( grid[ y - 1 ][ x + i - 1 ].cs === 1 ){
											cnc++;
										}
										break;
									// Neighbor to the left
									case 3:
										if( grid[ y ][ x - 1 ].cs === 1 ){
										 cnc++;
										}
										break;
									case 4:
										break;
									// Neighbor to the right
									case 5:
										if( grid[ y ][ x + 1 ].cs === 1 ){
										 cnc++;
										}
										break;
									// Neighbors below
									case 6:
									case 7:
									case 8:
										if( grid[ y + 1 ][ x + i - 7 ].cs === 1 ){
											cnc++;
										}
										break;
									default:
										break;
								}
							}

							// first rule
							if( cnc < 2 && grid[ y ][ x ].cs === 1 ){
								temp[ y ][ x ].cs = 0;
							}

							// second rule
							if( cnc < 1 && cnc > 4 && grid[ y ][ x ].cs === 1 ){
								temp[ y ][ x ].cs = 0;
							}

							// third rule
							if( cnc > 3 && grid[ y ][ x ].cs === 1 ){
								temp[ y ][ x ].cs = 0;
							}

							// fourth rule
							if( cnc == 3 && grid[ y ][ x ].cs === 0){
								temp[ y ][ x ].cs = 1;
							}
						}
					}

					grid = temp;
				}

			// Visually drawing function, which needs to be continuously called
			let draw = function(){
				// Clear canvas before redraw
				ctx.fillStyle = 'white';
				ctx.fillRect(0, 0, canvas.width, canvas.height );

				runAutomata();

				for( let y = 0; y < height; y++ ){
					for( let x = 0; x < width; x++ ){
						var dist = Math.abs( currentMouseGrid.y - y ) + Math.abs( currentMouseGrid.x - x );
						if( currentMouseGrid.y !== -1 && currentMouseGrid !== -1 &&
							Math.abs( currentMouseGrid.y - y ) <= Math.floor( mouseEffectSize / 2 ) &&
								dist < Math.ceil( mouseEffectSize / 2 ) ){
							grid[ y ][ x ] =
								variedColorLimiter( grid[ y ][ x ],
									darkenRate * mouseColor.r / 128 / (dist + 1),
									darkenRate * mouseColor.g / 128 / (dist + 1),
									darkenRate * mouseColor.b / 128 / (dist + 1),
									lightenRate);
							ctx.fillStyle = "rgb(" + Math.floor( grid[ y ][ x ].rcv ) + "," +
																			 Math.floor( grid[ y ][ x ].gcv ) + "," +
																			 Math.floor( grid[ y ][ x ].bcv ) + ")";
							ctx.fillRect( x * grid_width, y * grid_height, grid_width, grid_height );
						} else {
							// Cycling colors, alive cells become darker and dead cells become lighter
							grid[ y ][ x ] = colorLimiter( grid[ y ][ x ], darkenRate, lightenRate );
							ctx.fillStyle = "rgb(" + Math.floor( grid[ y ][ x ].rcv ) + "," +
																			 Math.floor( grid[ y ][ x ].gcv ) + "," +
																			 Math.floor( grid[ y ][ x ].bcv ) + ")";
							ctx.fillRect( x * grid_width + grid_width / 10, y * grid_height + grid_height / 10, grid_width * 4 / 5, grid_height * 4 / 5 );
						}
					}
				}
			}

			init();
			window.onresize = resize();
			window.setInterval( draw, refreshRate );
		</script>
	</body>
</html>
